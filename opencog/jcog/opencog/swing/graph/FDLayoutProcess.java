/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package jcog.opencog.swing.graph;

import com.syncleus.dann.graph.MutableDirectedAdjacencyGraph;
import edu.uci.ics.jung.graph.Hypergraph;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import javax.vecmath.Vector2f;
import jcog.math.RandomNumber;
import jcog.opencog.Atom;
import jcog.opencog.swing.GraphView2D;
import jcog.spacegraph.shape.Rect;

/**
 *
 * @author seh
 */
public class FDLayoutProcess extends GraphViewProcess {
    private MutableDirectedAdjacencyGraph<Atom, HyperedgeSegment> digraph;

    Map<Atom, Vector2f> coords = new HashMap();
    double repulsion = 0.01;
    double attraction = 0.01;
    float rad = 10.0f;
    
    public FDLayoutProcess() {
        super();
        reset();
    }

    /**
     * Creates a <code>Graph</code> which is an edge-folded version of <code>h</code>, where
     * hyperedges are replaced by k-cliques in the output graph.
     *
     * <p>The vertices of the new graph are the same objects as the vertices of
     * <code>h</code>, and <code>a</code>
     * is connected to <code>b</code> in the new graph if the corresponding vertices
     * in <code>h</code> are connected by a hyperedge.  Thus, each hyperedge with
     * <i>k</i> vertices in <code>h</code> induces a <i>k</i>-clique in the new graph.</p>
     *
     * <p>The edges of the new graph are generated by the specified edge factory.</p>
     *
     * @param <V> vertex type
     * @param <E> input edge type
     * @param h hypergraph to be folded
     * @param graph_factory factory used to generate the output graph
     * @param edge_factory factory used to create the new edges
     * @return a copy of the input graph where hyperedges are replaced by cliques
     */
    public MutableDirectedAdjacencyGraph<Atom, HyperedgeSegment> foldHypergraphEdges(final Collection<Atom> vertices, final MutableDirectedAdjacencyGraph<Atom, HyperedgeSegment> target, final Hypergraph<Atom, Atom> h, boolean linkEdgeToMembers) {
        for (Atom v : vertices) {
            target.add(v);
        }
        for (Atom e : h.getEdges()) {
            boolean contained = true;
            for (Atom iv : mind.getIncidentVertices(e)) {
                if (!vertices.contains(iv)) {
                    contained = false;
                    break;
                }
            }
            if (!contained) {
                continue;
            }
            target.add(e);
            ArrayList<Atom> incident = new ArrayList(h.getIncidentVertices(e));
            if (incident.size() == 0) {
                continue;
            }
            if (linkEdgeToMembers) {
                for (int i = 0; i < incident.size(); i++) {
                    Atom i1 = incident.get(i);
                    if (i == 0) {
                        target.add(new HyperedgeSegment(e, i1, e, "("));
                    } else {
                        target.add(new HyperedgeSegment(incident.get(i - 1), i1, e, ""));
                    }
                }
            } else {
                final String typeString = mind.getType(e).toString();
                //Just link the edge to the first element
                for (int i = 0; i < incident.size(); i++) {
                    if (i > 0) {
                        target.add(new HyperedgeSegment(incident.get(i - 1), incident.get(i), e, Integer.toString(i)));
                    } else {
                        target.add(new HyperedgeSegment(e, incident.get(i), e, "(" + typeString));
                    }
                }
            }
        }
        return target;
    }

    @Override
    public void reset() {
        super.reset();
        digraph = foldHypergraphEdges(graphView.atomRect.keySet(), new MutableDirectedAdjacencyGraph<Atom, HyperedgeSegment>(), mind.getAtomSpace().graph, true);
        Collection<HyperedgeSegment> diEdges = digraph.getEdges();

        graphView.edgeCurve.clear();
        for (HyperedgeSegment fe : diEdges) {
            graphView.addEdge(fe);
        }
        
//        ham = new SeHHyperassociativeMap<com.syncleus.dann.graph.Graph<Atom, FoldedEdge>, Atom>(digraph, numDimensions, true, GraphView.executor) {
//
//            @Override
//            public float getEquilibriumDistance(Atom n) {
//                return graphView.param.getVertexEquilibriumDistance(n);
//            }
//
//            @Override
//            public float getMeanEquilibriumDistance() {
//                return graphView.param.getMeanEquilibriumDistance();
//            }
//        };
        for (Atom a : graphView.atomRect.keySet()) {
            Rect r = graphView.atomRect.get(a);
            final float x = r.getCenter().x();
            final float y = r.getCenter().y();
            final float z = r.getCenter().z();
//            if (numDimensions >= 2) {
//                ham.getCoordinates().get(a).setCoordinate(x, 1);
//                ham.getCoordinates().get(a).setCoordinate(y, 2);
//            }
//            if (numDimensions >= 3) {
//                ham.getCoordinates().get(a).setCoordinate(z, 3);
//            }
            graphView.setTargetCenter(r, x, y, z);
        }
    }

    public Vector2f getCoords(Atom a) {
        Vector2f v = coords.get(a);
        if (v == null) {
            //TODO use random position within a given radius
            v = new Vector2f(RandomNumber.getFloat(-rad, rad), RandomNumber.getFloat(-rad, rad));
            coords.put(a, v);
        }
        return v;
    }
    
    public Vector2f getForce(Atom a, Atom b, double factor) {
        Vector2f aa = getCoords(a);
        Vector2f bb = getCoords(b);
        bb.sub(aa);
        bb.scale((float)factor);
        return bb;
    }
    
    @Override
    protected void update(GraphView2D g) {
        //cleanup coords
        List<Atom> toRemove = new LinkedList();
        for (Atom a : digraph.getNodes()) {
            if (!g.atomRect.containsKey(a))
                toRemove.add(a);
        }
        for (Atom a : toRemove)
            coords.remove(a);
        
        for (final Atom a : digraph.getNodes()) {
            final Vector2f v = getCoords(a);
            
            final Vector2f force = new Vector2f();
            for (final Atom b : coords.keySet()) {
                if (a != b) {
                    force.add(getForce(a, b, repulsion));
                }
            }
//            for (final Atom b : digraph.getAdjacentNodes(a)) {
//                force.add(getForce(a, b, attraction));                
//            }
            
            //TODO handle velocity integration correctly
            v.add(force);
        }
        
        final float s = 0.2F;
        for (Entry<Atom, Rect> i : g.atomRect.entrySet()) {
            final Vector2f v = getCoords(i.getKey());
            if (v == null) {
                System.err.println(i + " not mapped by " + this);
            }
            Rect tr = i.getValue();
            graphView.setTargetCenter(tr, v.getX(), v.getY(), 0);
        }
    }

    @Override
    public boolean isReady(GraphView2D graphView) {
        return accumulated > graphView.param.getLayoutUpdatePeriod();
    }
    
}
